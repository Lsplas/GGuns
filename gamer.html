<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PolyCombat: Balanced</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* BOSS UI */
        #boss-hud {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            width: 600px; text-align: center; display: none;
        }
        #boss-name { 
            color: #ff3333; font-weight: 900; font-size: 28px; 
            text-shadow: 0 0 10px #ff0000; margin-bottom: 5px;
        }
        #boss-bar-frame { width: 100%; height: 30px; background: #2a0000; border: 4px solid #550000; transform: skewX(-20deg); }
        #boss-bar-fill { width: 100%; height: 100%; background: #ff0000; transition: width 0.1s; box-shadow: 0 0 15px #ff0000; }

        /* QUEST UI */
        #quest-hud {
            position: absolute; top: 30px; right: 30px; text-align: right; display: none;
        }
        .quest-text { font-size: 30px; font-weight: bold; color: #00ff44; text-shadow: 0 0 10px #00ff00; }

        /* INTERACT PROMPT */
        #interact-msg {
            position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
            font-size: 24px; color: white; background: rgba(0,0,0,0.7); padding: 10px 20px;
            display: none; border: 2px solid #00ff44;
        }

        /* WAVE TITLE */
        #wave-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 80px; font-weight: 900; color: white; text-shadow: 0 0 30px #a200ff;
            opacity: 0; transition: opacity 0.5s; text-align: center; z-index: 50;
        }

        /* PLAYER STATS */
        #player-hud { position: absolute; bottom: 30px; left: 30px; display: flex; flex-direction: column; gap: 10px; }
        .stat-row { display: flex; align-items: center; gap: 10px; }
        .stat-label { font-weight: bold; color: white; width: 80px; }
        .bar-bg { width: 250px; height: 15px; background: rgba(0,0,0,0.6); border: 2px solid #444; transform: skewX(-15deg); }
        .bar-fill { height: 100%; transition: width 0.1s; }
        #hp-fill { background: #00ff44; }
        #stamina-fill { background: #00ccff; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: cyan; border-radius: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 8px cyan;
        }
        
        #dmg-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, red 150%);
            opacity: 0; transition: opacity 0.1s;
        }

        /* MENU */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20,0,30,0.98); display: flex; flex-direction: column;
            align-items: center; justify-content: center; pointer-events: auto; z-index: 100;
        }
        h1 { font-size: 80px; color: white; font-style: italic; text-shadow: 0 0 20px #8800ff; margin: 0; }
        p { color: #dcbfff; font-size: 20px; margin-bottom: 40px; text-align: center; max-width: 600px; }
        button {
            background: #8800ff; color: white; border: none; padding: 20px 60px;
            font-size: 24px; font-weight: 900; cursor: pointer; transform: skewX(-10deg);
            border: 2px solid white; transition: 0.2s; box-shadow: 0 0 15px #8800ff;
        }
        button:hover { background: white; color: #8800ff; transform: skewX(-10deg) scale(1.1); }
    </style>
</head>
<body>

    <div id="dmg-flash"></div>
    <div id="wave-msg">WAVE 1</div>
    <div id="interact-msg">PRESS [E] TO COLLECT</div>

    <div id="menu">
        <h1>POLY COMBAT</h1>
        <p>Minions are tough. Audio is ON.<br>Standard Controls (W = Forward).</p>
        <button id="play-btn">START MISSION</button>
    </div>

    <div id="ui-layer">
        <div id="boss-hud">
            <div id="boss-name">BOSS</div>
            <div id="boss-bar-frame"><div id="boss-bar-fill"></div></div>
        </div>

        <div id="quest-hud">
            <div class="quest-text">PACKETS: <span id="packet-count">0</span>/30</div>
        </div>

        <div id="crosshair"></div>

        <div id="player-hud">
            <div class="stat-row">
                <div class="stat-label">HP</div>
                <div class="bar-bg"><div class="bar-fill" id="hp-fill" style="width:100%"></div></div>
            </div>
            <div class="stat-row">
                <div class="stat-label">STAMINA</div>
                <div class="bar-bg"><div class="bar-fill" id="stamina-fill" style="width:100%"></div></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as CANNON from 'cannon-es';

        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            } 
            else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
            else if (type === 'die') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
            else if (type === 'collect') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            }
            else if (type === 'jump') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
        }

        // --- CONFIG ---
        const CONFIG = {
            gravity: -30,
            playerSpeed: 25,
            dashSpeed: 80,
            bulletSpeed: 150
        };

        const GAME = { 
            active: false, 
            wave: 0, 
            packets: 0, 
            canShoot: true,
            inCutscene: false
        };

        // --- SCENE ---
        const scene = new THREE.Scene();
        const skyColor = 0xaa55ff; // Neon Light Purple
        scene.background = new THREE.Color(skyColor); 
        scene.fog = new THREE.FogExp2(skyColor, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffccff, 0.8);
        sun.position.set(20, 50, 20);
        sun.castShadow = true;
        scene.add(sun);
        const pLight = new THREE.PointLight(0x00ffff, 0.5, 20);
        camera.add(pLight);

        // --- PHYSICS ---
        const world = new CANNON.World();
        world.gravity.set(0, CONFIG.gravity, 0);
        const matDefault = new CANNON.Material();
        const matPlayer = new CANNON.Material();
        const matEntity = new CANNON.Material();
        
        world.addContactMaterial(new CANNON.ContactMaterial(matDefault, matPlayer, { friction: 0.0, restitution: 0 }));
        world.addContactMaterial(new CANNON.ContactMaterial(matDefault, matEntity, { friction: 0.0, restitution: 0 }));

        // --- SHAKE ---
        let shakeIntensity = 0;
        function addShake(amt) { shakeIntensity = amt; }
        function updateShake() {
            if(shakeIntensity > 0) {
                camera.position.x += (Math.random()-0.5)*shakeIntensity;
                camera.position.y += (Math.random()-0.5)*shakeIntensity;
                shakeIntensity *= 0.9;
                if(shakeIntensity < 0.01) shakeIntensity = 0;
            }
        }

        // --- PARTICLES ---
        const particles = [];
        function spawnParticles(pos, count, color, scale=1) {
            const geo = new THREE.BoxGeometry(0.3*scale, 0.3*scale, 0.3*scale);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.add(new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, (Math.random()-0.5)*3));
                scene.add(mesh);
                particles.push({ 
                    mesh, 
                    vel: new THREE.Vector3((Math.random()-0.5)*15, Math.random()*15, (Math.random()-0.5)*15), 
                    life: 1.0 
                });
            }
        }

        // --- WEAPON ---
        const gunGroup = new THREE.Group();
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x222 });
        const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.25, 0.8), gunMat);
        const gunBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8), new THREE.MeshStandardMaterial({color:0x00ff00, emissive:0x004400}));
        gunBarrel.rotation.x = Math.PI/2; gunBarrel.position.z = -0.6;
        gunGroup.add(gunBody, gunBarrel);
        gunGroup.position.set(0.4, -0.35, -0.6);
        camera.add(gunGroup);
        scene.add(camera);

        // --- PLAYER ---
        class Player {
            constructor() {
                this.hp = 100;
                this.stamina = 100;
                this.body = new CANNON.Body({ mass: 5, shape: new CANNON.Sphere(1.5), material: matPlayer, fixedRotation: true });
                this.body.position.set(0, 5, 30);
                this.body.linearDamping = 0.9;
                world.addBody(this.body);
            }
            update(dt, input) {
                if(GAME.inCutscene) {
                    this.body.velocity.set(0,0,0);
                    return;
                }
                if(!input.shift) this.stamina = Math.min(100, this.stamina + dt*20);
                document.getElementById('stamina-fill').style.width = this.stamina + '%';

                // Gun Visibility
                gunGroup.visible = GAME.canShoot;
                document.getElementById('crosshair').style.display = GAME.canShoot ? 'block' : 'none';

                const yaw = camera.rotation.y;
                const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
                const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

                let speed = input.shift && this.stamina > 20 ? CONFIG.dashSpeed : CONFIG.playerSpeed;
                if(input.shift && this.stamina > 20) { this.stamina -= dt*60; camera.fov = THREE.MathUtils.lerp(camera.fov, 90, 0.1); }
                else camera.fov = THREE.MathUtils.lerp(camera.fov, 75, 0.1);
                camera.updateProjectionMatrix();

                const move = new THREE.Vector3();
                // STANDARD CONTROLS (W = Forward)
                if(input.w) move.add(fwd); if(input.s) move.sub(fwd);
                if(input.d) move.add(right); if(input.a) move.sub(right);
                move.normalize();

                this.body.velocity.x = move.x * speed;
                this.body.velocity.z = move.z * speed;
                if(input.space && Math.abs(this.body.velocity.y) < 0.1) {
                    this.body.velocity.y = 15;
                    playSound('jump');
                }

                camera.position.copy(this.body.position).add(new THREE.Vector3(0,1.5,0));
                updateShake();
                
                gunGroup.position.x = THREE.MathUtils.lerp(gunGroup.position.x, 0.4 + move.x * -0.05, 0.1);
                gunGroup.position.y = THREE.MathUtils.lerp(gunGroup.position.y, -0.35 + Math.sin(Date.now()*0.01)*0.01, 0.1);
            }
            takeDamage(amt) {
                if(GAME.inCutscene) return;
                this.hp -= amt;
                document.getElementById('hp-fill').style.width = Math.max(0, this.hp) + '%';
                addShake(0.5);
                playSound('hit');
                const f = document.getElementById('dmg-flash'); f.style.opacity = 0.8;
                setTimeout(()=>f.style.opacity=0, 200);
                if(this.hp <= 0) { alert("YOU DIED"); location.reload(); }
            }
        }

        // --- MINIONS (ROBLOX STYLE) ---
        class Minion {
            constructor(pos) {
                // BALANCED HP
                this.hp = 150; // Takes about 4-5 hits
                
                this.mesh = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0xffff00 }); // Yellow skin
                const blue = new THREE.MeshStandardMaterial({ color: 0x0000ff });
                
                const head = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), mat); head.position.y=2.5;
                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,0.8), blue); torso.position.y=1.25;
                const armR = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.5,0.4), mat); armR.position.set(1, 1.25, 0.5); armR.rotation.x = -Math.PI/2;
                const armL = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.5,0.4), mat); armL.position.set(-1, 1.25, 0);
                
                // Gun
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 1), new THREE.MeshBasicMaterial({color:0x000000}));
                gun.position.set(0, -0.8, 0.5); armR.add(gun);

                this.mesh.add(head, torso, armR, armL);
                this.mesh.position.copy(pos);
                scene.add(this.mesh);

                this.body = new CANNON.Body({ mass: 50, fixedRotation: true, shape: new CANNON.Box(new CANNON.Vec3(0.5, 1.5, 0.5)), material: matEntity });
                this.body.position.copy(pos);
                world.addBody(this.body);

                this.shootTimer = Date.now() + Math.random()*2000;
            }
            update(playerPos, dt) {
                const dir = new THREE.Vector3().subVectors(playerPos, this.body.position).normalize();
                this.mesh.position.copy(this.body.position);
                this.mesh.position.y -= 1.5; // Offset
                this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);

                const dist = this.body.position.distanceTo(playerPos);
                if(dist > 15) {
                    this.body.velocity.x = dir.x * 10;
                    this.body.velocity.z = dir.z * 10;
                } else {
                    this.body.velocity.x = 0; this.body.velocity.z = 0;
                }

                // Shoot
                if(Date.now() > this.shootTimer && dist < 40) {
                    this.shootTimer = Date.now() + 2000;
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff0000}));
                    b.position.copy(this.body.position).add(new THREE.Vector3(0,1,0));
                    scene.add(b);
                    enemyBullets.push({ mesh:b, dir:dir.clone(), life: 100 });
                    playSound('shoot');
                }
            }
            takeDamage(amt) {
                this.hp -= amt;
                playSound('hit');
                if(this.hp <= 0) {
                    playSound('die');
                    spawnParticles(this.body.position, 10, 0xffff00);
                    scene.remove(this.mesh);
                    world.removeBody(this.body);
                    return true; // Dead
                }
                return false;
            }
        }

        // --- BOSSES ---
        class Boss {
            constructor(type) {
                this.type = type;
                this.maxHp = type === 1 ? 2000 : (type === 2 ? 4000 : 10000); 
                this.hp = this.maxHp;
                this.isDead = false;
                
                this.nextScream = 0;

                this.mesh = new THREE.Group();
                let mat;
                if(type === 3) mat = new THREE.MeshStandardMaterial({ color: 0x880000, roughness: 0.5 });
                else mat = new THREE.MeshStandardMaterial({ color: type===1?0x888899:0x111111, metalness: 0.8 });
                
                // Body Parts
                const legG = new THREE.BoxGeometry(1.5, 4, 1.5);
                this.legL = new THREE.Mesh(legG, mat); this.legL.position.set(-1.5, 2, 0);
                this.legR = new THREE.Mesh(legG, mat); this.legR.position.set(1.5, 2, 0);
                const torso = new THREE.Mesh(new THREE.BoxGeometry(4, 5, 2.5), mat); torso.position.y = 6.5;
                const head = new THREE.Mesh(new THREE.BoxGeometry(2, type===3?3:2.5, 2), mat); head.position.y = type===3?11:10;
                
                this.armL = new THREE.Mesh(new THREE.BoxGeometry(1.2, type===3?8:5, 1.2), mat); this.armL.position.set(-2.8, 7, 0);
                this.armR = new THREE.Mesh(new THREE.BoxGeometry(1.2, type===3?8:5, 1.2), mat); this.armR.position.set(2.8, 7, 0);

                if(type === 3) {
                    const mouth = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.0, 0.2), new THREE.MeshBasicMaterial({color:0xffff00}));
                    mouth.position.set(0, 11, 1.0); this.mesh.add(mouth);
                } else {
                    const eye = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.4, 0.2), new THREE.MeshBasicMaterial({color: type===1?0x00ffff:0xaa00ff}));
                    eye.position.set(0, 10, 1.0); this.mesh.add(eye);
                }

                this.mesh.add(this.legL, this.legR, torso, head, this.armL, this.armR);
                scene.add(this.mesh);

                this.body = new CANNON.Body({ mass: 1000, fixedRotation: true, shape: new CANNON.Box(new CANNON.Vec3(2, 6, 2)), material: matEntity });
                this.body.position.set(0, 10, type===3 ? -80 : -40); 
                if(type===3) this.body.position.set(0,10,0); 
                world.addBody(this.body);

                const hud = document.getElementById('boss-hud');
                hud.style.display = 'block';
                const names = ["", "IRON KNIGHT", "SHADOW STALKER", "THE FIGURE"];
                document.getElementById('boss-name').innerText = names[type];
                document.getElementById('boss-bar-fill').style.width = '100%';
            }

            update(playerPos, dt) {
                if(this.isDead) return true;
                if(GAME.inCutscene) {
                    this.body.velocity.set(0,0,0);
                    return false;
                }

                const dist = this.body.position.distanceTo(playerPos);
                const t = Date.now() * 0.01;

                if(this.type === 3) {
                    if(dist < 30) {
                         const dir = new THREE.Vector3().subVectors(playerPos, this.body.position).normalize();
                         this.body.velocity.x = dir.x * 35;
                         this.body.velocity.z = dir.z * 35;
                         
                         if(Date.now() > this.nextScream) {
                             addShake(3.0);
                             playSound('die'); 
                             this.nextScream = Date.now() + 2000;
                         }
                         if(dist < 6) {
                             this.armL.rotation.x = -Math.PI/2 + Math.sin(t*20);
                             this.armR.rotation.x = -Math.PI/2 - Math.sin(t*20);
                             if(Math.random()>0.9) player.takeDamage(5); 
                         }
                    } else {
                        if(Math.random() > 0.98) {
                            this.wanderDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                        }
                        if(this.wanderDir) {
                            this.body.velocity.x = this.wanderDir.x * 15;
                            this.body.velocity.z = this.wanderDir.z * 15;
                        }
                    }
                } 
                else {
                    const speed = this.type === 1 ? 40 : 60;
                    const dir = new THREE.Vector3().subVectors(playerPos, this.body.position).normalize();
                    this.body.velocity.x = dir.x * speed;
                    this.body.velocity.z = dir.z * speed;
                    
                    if(dist < 8) {
                        this.armR.rotation.x = -Math.PI/2 + Math.sin(t*10);
                        if(Math.random()>0.95) player.takeDamage(1);
                    }
                }

                this.mesh.position.copy(this.body.position);
                this.mesh.position.y -= 6;
                this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
                
                this.legL.rotation.x = Math.sin(t*8)*0.8;
                this.legR.rotation.x = Math.sin(t*8+Math.PI)*0.8;

                return false;
            }

            takeDamage(amt) {
                if(this.type === 3) return; 
                this.hp -= amt;
                playSound('hit');
                document.getElementById('boss-bar-fill').style.width = (this.hp/this.maxHp)*100 + '%';
                if(this.hp <= 0) {
                    this.isDead = true;
                    playSound('die');
                    world.removeBody(this.body);
                    scene.remove(this.mesh);
                    spawnParticles(this.mesh.position, 100, 0xffaa00, 2);
                    
                    if(this.type === 1) startWave(2);
                    else if(this.type === 2) startWave(3);
                }
            }
        }

        // --- NUCLEAR PACKETS ---
        const packets = [];
        class Packet {
            constructor(x, z) {
                this.mesh = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true}));
                this.mesh.position.set(x, 2, z);
                const inner = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color:0xccffcc}));
                this.mesh.add(inner);
                scene.add(this.mesh);
                this.pos = new THREE.Vector3(x,2,z);
                this.active = true;
            }
            update(playerPos) {
                if(!this.active) return;
                this.mesh.rotation.y += 0.05;
                if(this.pos.distanceTo(playerPos) < 5) {
                    document.getElementById('interact-msg').style.display = 'block';
                    return true; 
                }
                return false;
            }
            collect() {
                if(!this.active) return;
                this.active = false;
                playSound('collect');
                scene.remove(this.mesh);
                spawnParticles(this.pos, 10, 0x00ff00);
                GAME.packets++;
                document.getElementById('packet-count').innerText = GAME.packets;
                if(GAME.packets >= 30) triggerEnding();
            }
        }

        // --- GAME LOGIC ---
        let currentBoss = null;
        let minions = [];
        let enemyBullets = [];
        const player = new Player();
        const mapObjects = [];

        function clearMap() {
            mapObjects.forEach(obj => { scene.remove(obj.mesh); world.removeBody(obj.body); });
            mapObjects.length = 0;
            minions.forEach(m => { scene.remove(m.mesh); world.removeBody(m.body); });
            minions = [];
        }

        function buildLibrary() {
            clearMap();
            GAME.canShoot = false;
            document.getElementById('quest-hud').style.display = 'block';
            
            const shelfGeo = new THREE.BoxGeometry(4, 20, 15);
            const shelfMat = new THREE.MeshStandardMaterial({color:0x331100});
            
            for(let x=-80; x<=80; x+=20) {
                for(let z=-80; z<=80; z+=25) {
                    if(Math.random() > 0.8) continue; 
                    if(Math.abs(x) < 10 && Math.abs(z) < 10) continue; 

                    const m = new THREE.Mesh(shelfGeo, shelfMat);
                    m.position.set(x, 10, z);
                    scene.add(m);
                    const b = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(2,10,7.5)) });
                    b.position.set(x, 10, z);
                    world.addBody(b);
                    mapObjects.push({mesh:m, body:b});
                }
            }

            for(let i=0; i<30; i++) {
                const x = (Math.random()-0.5)*150;
                const z = (Math.random()-0.5)*150;
                packets.push(new Packet(x, z));
            }
        }

        function startWave(n) {
            GAME.wave = n;
            const title = document.getElementById('wave-msg');
            if(n===1) title.innerText = "WAVE 1: IRON KNIGHT";
            if(n===2) title.innerText = "WAVE 2: SHADOW STALKER";
            if(n===3) title.innerText = "THE LIBRARY";
            
            title.style.opacity = 1; 
            setTimeout(()=>title.style.opacity=0, 4000);

            if(n < 3) {
                currentBoss = new Boss(n);
                for(let i=0; i<5; i++) {
                    minions.push(new Minion(new THREE.Vector3((Math.random()-0.5)*50, 5, (Math.random()-0.5)*50)));
                }
            } else {
                buildLibrary();
                currentBoss = new Boss(3);
                player.body.position.set(0,5,0);
            }
        }

        // --- CUTSCENE ---
        function triggerEnding() {
            if(GAME.inCutscene) return;
            GAME.inCutscene = true;
            document.getElementById('quest-hud').style.display = 'none';
            document.getElementById('wave-msg').innerText = "CRAFTING NUKE...";
            document.getElementById('wave-msg').style.color = "lime";
            document.getElementById('wave-msg').style.opacity = 1;

            const targetPos = player.body.position.clone();
            currentBoss.body.position.set(targetPos.x + 10, 5, targetPos.z);
            currentBoss.body.velocity.set(0,0,0);
            
            setTimeout(() => {
                currentBoss.mesh.position.set(targetPos.x+2, 5, targetPos.z);
                camera.lookAt(currentBoss.mesh.position);
            }, 100);

            setTimeout(() => {
                document.getElementById('wave-msg').innerText = "LAUNCHER READY!";
                playSound('collect');
                gunGroup.visible = true; 
                gunGroup.children[0].scale.set(3,3,3); 
                gunGroup.children[0].material.color.setHex(0x00ff00);
            }, 2000);

            setTimeout(() => {
                spawnParticles(currentBoss.mesh.position, 500, 0x00ff00, 5); 
                spawnParticles(currentBoss.mesh.position, 200, 0xff0000, 2); 
                playSound('die');
                scene.remove(currentBoss.mesh);
                addShake(10);
                document.body.style.backgroundColor = "white"; 
                setTimeout(()=> document.body.style.backgroundColor = "#000", 100);
            }, 3000);

            setTimeout(() => {
                playSound('win');
                alert("VICTORY! THE FIGURE DESTROYED.");
                location.reload();
            }, 4000);
        }

        // --- INPUT ---
        const keys = { w:0, a:0, s:0, d:0, shift:0, space:0 };
        document.onkeydown = e => { 
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true; 
            if(e.key==='Shift') keys.shift=true; 
            if(e.code==='Space') keys.space=true; 

            if(k === 'e' && GAME.wave === 3) {
                packets.forEach(p => {
                    if(p.update(player.body.position)) p.collect();
                });
            }
        };
        document.onkeyup = e => { 
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false; 
            if(e.key==='Shift') keys.shift=false; 
            if(e.code==='Space') keys.space=false; 
        };
        document.onmousedown = () => { if(GAME.active && GAME.canShoot) shoot(); };

        const bullets = [];
        function shoot() {
            playSound('shoot');
            addShake(0.2); gunGroup.position.z += 0.3; gunGroup.rotation.x += 0.2;
            const m = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0x00ffff}));
            m.position.copy(camera.position); scene.add(m);
            const b = new CANNON.Body({ mass: 0.1, shape: new CANNON.Sphere(0.15) });
            b.position.copy(camera.position);
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            b.velocity.set(dir.x*CONFIG.bulletSpeed, dir.y*CONFIG.bulletSpeed, dir.z*CONFIG.bulletSpeed);
            world.addBody(b);
            bullets.push({mesh:m, body:b, life:60});
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        const controls = new PointerLockControls(camera, document.body);
        document.getElementById('play-btn').onclick = () => { 
            if(audioCtx.state === 'suspended') audioCtx.resume();
            controls.lock(); GAME.active = true; document.getElementById('menu').style.display='none'; 
            startWave(1); 
        };

        const floor = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
        floor.quaternion.setFromEuler(-Math.PI/2, 0, 0); world.addBody(floor);
        const grid = new THREE.GridHelper(200, 50, 0x8800ff, 0x220044); scene.add(grid);

        function animate() {
            requestAnimationFrame(animate);
            if(!GAME.active) return;
            const dt = Math.min(clock.getDelta(), 0.1);
            world.step(1/60, dt, 3);
            player.update(dt, keys);
            
            let canInteract = false;
            if(GAME.wave === 3) {
                packets.forEach(p => { if(p.update(player.body.position)) canInteract = true; });
            }
            document.getElementById('interact-msg').style.display = canInteract ? 'block' : 'none';

            for(let i=minions.length-1; i>=0; i--) {
                minions[i].update(player.body.position, dt);
            }

            if(currentBoss) currentBoss.update(player.body.position, dt);

            if(GAME.inCutscene && currentBoss && !currentBoss.isDead) {
                camera.lookAt(currentBoss.mesh.position.x, currentBoss.mesh.position.y + 8, currentBoss.mesh.position.z);
            }

            gunGroup.position.z = THREE.MathUtils.lerp(gunGroup.position.z, -0.6, 0.1);
            gunGroup.rotation.x = THREE.MathUtils.lerp(gunGroup.rotation.x, 0, 0.1);

            for(let i=bullets.length-1; i>=0; i--) {
                const b = bullets[i];
                b.mesh.position.copy(b.body.position);
                b.life--;
                
                if(currentBoss && !currentBoss.isDead && b.mesh.position.distanceTo(currentBoss.mesh.position) < 5) {
                    currentBoss.takeDamage(15); spawnParticles(b.mesh.position, 5, 0x00ffff);
                    scene.remove(b.mesh); world.removeBody(b.body); bullets.splice(i,1); continue;
                }
                let hitMinion = false;
                for(let j=minions.length-1; j>=0; j--) {
                    if(b.mesh.position.distanceTo(minions[j].mesh.position) < 2) {
                        if(minions[j].takeDamage(35)) minions.splice(j,1);
                        hitMinion = true; break;
                    }
                }
                if(hitMinion) { scene.remove(b.mesh); world.removeBody(b.body); bullets.splice(i,1); continue; }

                if(b.life<=0 || b.mesh.position.y<0) { scene.remove(b.mesh); world.removeBody(b.body); bullets.splice(i,1); }
            }

            for(let i=enemyBullets.length-1; i>=0; i--) {
                const b = enemyBullets[i];
                b.mesh.position.addScaledVector(b.dir, 40*dt);
                b.life--;
                if(b.mesh.position.distanceTo(player.body.position) < 2) {
                    player.takeDamage(15); // Increased Damage
                    scene.remove(b.mesh); enemyBullets.splice(i,1); continue;
                }
                if(b.life<=0) { scene.remove(b.mesh); enemyBullets.splice(i,1); }
            }

            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i]; p.life -= dt;
                p.mesh.position.addScaledVector(p.vel, dt); p.mesh.scale.setScalar(p.life);
                if(p.life<=0) { scene.remove(p.mesh); particles.splice(i,1); }
            }
            renderer.render(scene, camera);
        }
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
        animate();
    </script>
</body>
</html>
