<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PolyCombat: Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Arial', sans-serif; user-select: none; }

        /* UI OVERLAYS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* CROSSHAIR */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: rgba(0, 255, 0, 0.8); border: 2px solid white; border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* SCOREBOARD (Top) */
        #top-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 10px 40px; border-radius: 20px;
            color: white; font-size: 24px; font-weight: bold; border: 2px solid #fff;
            display: flex; gap: 30px;
        }

        /* STATUS (Bottom) */
        #status-bar {
            position: absolute; bottom: 30px; left: 30px;
            display: flex; gap: 20px;
        }
        .stat-card {
            background: rgba(0,0,0,0.6); padding: 15px; color: white;
            font-size: 20px; font-weight: bold; border-left: 5px solid;
            width: 150px;
        }

        /* START SCREEN */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white; pointer-events: auto;
        }
        .btn {
            background: #00ff00; color: black; padding: 20px 50px; font-size: 30px;
            border: none; cursor: pointer; font-weight: bold; margin-top: 20px;
        }
        .btn:hover { background: white; }

        /* DAMAGE FLASH */
        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; transition: opacity 0.1s; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="flash"></div>

    <div id="start-screen">
        <h1 style="font-size: 60px;">POLY COMBAT</h1>
        <p>WASD to Move | SPACE to Jump | CLICK to Shoot</p>
        <button class="btn" id="start-btn">PLAY NOW</button>
    </div>

    <div id="ui-layer">
        <div id="top-bar">
            <span>KILLS: <span id="kill-count" style="color:yellow">0</span></span>
            <span>SCORE: <span id="score-count" style="color:#00ff00">0</span></span>
        </div>
        <div id="crosshair"></div>
        <div id="status-bar">
            <div class="stat-card" style="border-color: red;">‚ù§Ô∏è <span id="hp-txt">100</span></div>
            <div class="stat-card" style="border-color: cyan;">üî´ <span id="ammo-txt">30</span></div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import * as CANNON from 'cannon-es';

        // --- GAME STATE ---
        const state = {
            hp: 100, kills: 0, score: 0, ammo: 30,
            canShoot: true,
            isGameActive: false
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Nice Sky Blue
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100); // Distance fog to hide edge of world

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); // Antialias reduces jagged lines
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- PHYSICS WORLD ---
        const world = new CANNON.World();
        world.gravity.set(0, -30, 0); // Stronger gravity for snappy jumping
        
        // Materials (Friction)
        const groundMat = new CANNON.Material();
        const playerMat = new CANNON.Material();
        const contactMat = new CANNON.ContactMaterial(groundMat, playerMat, {
            friction: 0.0, // Zero friction for player movement (prevents sticking to walls)
            restitution: 0.0
        });
        world.addContactMaterial(contactMat);

        // --- PLAYER ---
        const playerBody = new CANNON.Body({
            mass: 5, // Heavy enough to fall
            material: playerMat,
            shape: new CANNON.Sphere(1.5), // Sphere shape prevents getting stuck in corners
            fixedRotation: true // Crucial: Prevents player from rolling over
        });
        playerBody.position.set(0, 10, 0); // Spawn in air
        playerBody.linearDamping = 0.9; // Air resistance (prevents sliding forever)
        world.addBody(playerBody);

        // Weapon Model (Simple box attached to camera)
        const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), new THREE.MeshStandardMaterial({color: 0x333333}));
        gun.position.set(0.5, -0.5, -1);
        camera.add(gun);
        scene.add(camera);

        // --- MAP GENERATION ---
        const objects = []; // Keep track of physical objects

        function createBox(w, h, d, x, y, z, color, mass=0) {
            // Visuals
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Physics
            const body = new CANNON.Body({
                mass: mass,
                shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)),
                material: groundMat
            });
            body.position.set(x, y, z);
            world.addBody(body);

            return { mesh, body };
        }

        // 1. The Floor (Make it THICK to prevent falling through)
        createBox(200, 10, 200, 0, -5, 0, 0x228B22); 

        // 2. Obstacles
        createBox(10, 5, 10, 15, 2.5, 15, 0x555555);
        createBox(20, 8, 2, -10, 4, -20, 0x8B4513);
        createBox(5, 3, 5, -20, 1.5, 5, 0x333333);
        createBox(8, 2, 8, 20, 1, -10, 0x444444);

        // --- CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const startBtn = document.getElementById('start-btn');
        const startScreen = document.getElementById('start-screen');

        startBtn.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            startScreen.style.display = 'none';
            state.isGameActive = true;
        });
        controls.addEventListener('unlock', () => {
            startScreen.style.display = 'flex';
            state.isGameActive = false;
        });

        // Input Tracking
        const keys = { w:0, a:0, s:0, d:0, space:0 };
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = 1; break;
                case 'KeyS': keys.s = 1; break;
                case 'KeyA': keys.a = 1; break;
                case 'KeyD': keys.d = 1; break;
                case 'Space': keys.space = 1; break;
                case 'KeyR': respawn(); break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = 0; break;
                case 'KeyS': keys.s = 0; break;
                case 'KeyA': keys.a = 0; break;
                case 'KeyD': keys.d = 0; break;
                case 'Space': keys.space = 0; break;
            }
        });

        document.addEventListener('mousedown', () => {
            if(state.isGameActive) shoot();
        });

        // --- SHOOTING & BULLETS ---
        const bullets = [];
        function shoot() {
            if(!state.canShoot || state.ammo <= 0) return;
            
            state.ammo--;
            updateUI();
            
            // Recoil Animation
            gun.position.z = -0.8;
            setTimeout(() => gun.position.z = -1, 100);

            // Create Bullet (Visual + Physics)
            const bGeo = new THREE.SphereGeometry(0.2);
            const bMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const bMesh = new THREE.Mesh(bGeo, bMat);
            
            // Start at camera position
            bMesh.position.copy(camera.position);
            scene.add(bMesh);

            const bBody = new CANNON.Body({ mass: 0.1, shape: new CANNON.Sphere(0.2) });
            bBody.position.copy(camera.position);
            
            // Get Shooting Direction
            const shootDir = new THREE.Vector3();
            camera.getWorldDirection(shootDir);
            
            // Apply velocity
            const speed = 100;
            bBody.velocity.set(shootDir.x * speed, shootDir.y * speed, shootDir.z * speed);
            world.addBody(bBody);

            bullets.push({ mesh: bMesh, body: bBody, life: 100 }); // Life = frames to live
        }

        // --- BOTS (ENEMIES) ---
        const bots = [];
        function spawnBot() {
            const x = (Math.random() - 0.5) * 60;
            const z = (Math.random() - 0.5) * 60;
            
            const group = new THREE.Group();
            
            // Bot Body (Red Box)
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 3, 1.5),
                new THREE.MeshStandardMaterial({color: 0xff0000})
            );
            mesh.position.y = 1.5;
            group.add(mesh);
            scene.add(group);

            const body = new CANNON.Body({
                mass: 5,
                shape: new CANNON.Box(new CANNON.Vec3(0.75, 1.5, 0.75)),
                fixedRotation: true
            });
            body.position.set(x, 10, z);
            world.addBody(body);

            bots.push({ mesh: group, body: body, hp: 3 });
        }

        // Spawn 5 bots initially
        for(let i=0; i<5; i++) spawnBot();

        // --- GAME LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            if(!state.isGameActive) return;

            const dt = Math.min(clock.getDelta(), 0.1);
            world.step(1/60, dt, 3);

            // 1. PLAYER MOVEMENT
            // Get camera direction (Y-only for movement)
            const angleY = Math.atan2(
                (camera.position.x - playerBody.position.x), 
                (camera.position.z - playerBody.position.z)
            );
            
            // Calculate Yaw (rotation around Y axis)
            const yaw = new THREE.Euler(0, 0, 0, 'YXZ');
            yaw.setFromQuaternion(camera.quaternion);

            const moveSpeed = 15;
            const inputVector = new THREE.Vector3(0, 0, 0);

            if(keys.w) inputVector.z = -1;
            if(keys.s) inputVector.z = 1;
            if(keys.a) inputVector.x = -1;
            if(keys.d) inputVector.x = 1;

            // Rotate input vector by camera Yaw
            inputVector.applyAxisAngle(new THREE.Vector3(0,1,0), yaw.y);

            playerBody.velocity.x = inputVector.x * moveSpeed;
            playerBody.velocity.z = inputVector.z * moveSpeed;

            // Jumping (Simple Raycast Check for Floor)
            const rayStart = new CANNON.Vec3(playerBody.position.x, playerBody.position.y, playerBody.position.z);
            const rayEnd = new CANNON.Vec3(playerBody.position.x, playerBody.position.y - 2.0, playerBody.position.z);
            const result = new CANNON.RaycastResult();
            world.raycastClosest(rayStart, rayEnd, {}, result);
            
            if (result.hasHit && keys.space) {
                playerBody.velocity.y = 15; // Jump Force
            }

            // Sync Camera to Physics Body
            camera.position.set(playerBody.position.x, playerBody.position.y + 0.8, playerBody.position.z);

            // 2. BULLET LOGIC
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.copy(b.body.position);
                b.life--;

                // Collision Check (Naive distance check for performance)
                let hit = false;
                for (let j = bots.length - 1; j >= 0; j--) {
                    const bot = bots[j];
                    const dist = b.mesh.position.distanceTo(bot.mesh.position);
                    if (dist < 2) {
                        hit = true;
                        bot.hp--;
                        // Visual Hit feedback
                        bot.mesh.children[0].material.color.setHex(0xffffff);
                        setTimeout(() => { if(bot.mesh) bot.mesh.children[0].material.color.setHex(0xff0000); }, 50);

                        if (bot.hp <= 0) {
                            // Kill Bot
                            scene.remove(bot.mesh);
                            world.removeBody(bot.body);
                            bots.splice(j, 1);
                            state.kills++;
                            state.score += 100;
                            updateUI();
                            // Respawn new bot
                            setTimeout(spawnBot, 2000);
                        }
                    }
                }

                if (b.life <= 0 || hit) {
                    scene.remove(b.mesh);
                    world.removeBody(b.body);
                    bullets.splice(i, 1);
                }
            }

            // 3. BOT LOGIC (Simple AI)
            bots.forEach(bot => {
                bot.mesh.position.copy(bot.body.position);
                bot.mesh.lookAt(playerBody.position); // Look at player
                
                // Move towards player
                const dir = new THREE.Vector3().subVectors(playerBody.position, bot.mesh.position).normalize();
                bot.body.velocity.x = dir.x * 5;
                bot.body.velocity.z = dir.z * 5;

                // Damage Player
                if(bot.mesh.position.distanceTo(playerBody.position) < 2.5) {
                    takeDamage();
                }
                
                // Keep upright
                bot.body.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), bot.mesh.rotation.y);
            });

            // Void Check
            if(playerBody.position.y < -20) respawn();

            renderer.render(scene, camera);
        }

        // --- HELPERS ---
        function takeDamage() {
            state.hp -= 1;
            updateUI();
            document.getElementById('flash').style.opacity = 0.5;
            setTimeout(() => document.getElementById('flash').style.opacity = 0, 100);
            
            if(state.hp <= 0) {
                alert("GAME OVER! Score: " + state.score);
                location.reload();
            }
        }

        function respawn() {
            playerBody.position.set(0, 10, 0);
            playerBody.velocity.set(0,0,0);
        }

        function updateUI() {
            document.getElementById('kill-count').innerText = state.kills;
            document.getElementById('score-count').innerText = state.score;
            document.getElementById('hp-txt').innerText = state.hp;
            document.getElementById('ammo-txt').innerText = state.ammo;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        animate();

    </script>
</body>
</html>
