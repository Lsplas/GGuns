<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOORS: GRAND LIBRARY</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* UI OVERLAY */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* HUD */
        #hud-top { 
            display: flex; justify-content: space-between; padding: 20px; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .hud-box { color: white; font-weight: bold; text-shadow: 0 0 5px black; }
        #items-count { font-size: 30px; color: #00ffaa; }
        #status-msg { font-size: 24px; color: red; opacity: 0; transition: opacity 0.2s; }

        /* CENTER */
        #center-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; flex-direction: column; align-items: center;
        }
        #crosshair { width: 8px; height: 8px; background: rgba(255,255,255,0.8); border-radius: 50%; box-shadow: 0 0 4px white; }
        #interact-text { 
            margin-top: 20px; color: white; background: rgba(0,0,0,0.7); 
            padding: 5px 10px; border-radius: 4px; opacity: 0; 
            font-size: 18px; border: 1px solid #aaa;
        }

        /* BOTTOM */
        #controls-hint {
            position: absolute; bottom: 20px; left: 20px; color: #888; font-size: 14px;
        }
        #posture-icon {
            position: absolute; bottom: 20px; right: 20px; font-size: 50px; 
            filter: drop-shadow(0 0 5px black); transition: transform 0.2s;
        }

        /* MENUS */
        #start-screen, #death-screen, #win-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center;
        }
        #death-screen { background: #300; display: none; }
        #win-screen { background: #002211; display: none; }
        
        h1 { font-size: 60px; margin: 0 0 20px 0; color: #e67e22; text-shadow: 0 0 20px orange; }
        p { font-size: 18px; color: #ccc; max-width: 600px; line-height: 1.5; margin-bottom: 30px; }
        button {
            padding: 15px 40px; font-size: 20px; font-weight: bold; cursor: pointer;
            background: #e67e22; border: none; border-radius: 5px; color: black;
        }
        button:hover { background: white; }

        /* JUMPSCARE */
        #jumpscare-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 200; display: none;
            align-items: center; justify-content: center;
        }
        #scare-img {
            width: 100%; height: 100%; object-fit: cover;
            animation: shake 0.05s infinite;
        }
        @keyframes shake { 0% { transform: translate(5px, 5px); } 50% { transform: translate(-5px, -5px); } 100% { transform: translate(0,0); } }

    </style>
</head>
<body>

    <div id="start-screen">
        <h1>DOOR 100: EXPANDED</h1>
        <p>1. Crouch (<b>C</b>) to stay quiet.<br>
           2. If you <b>RUN</b>, the Figure will hear you.<br>
           3. Collect <b>10 Breakers</b> to power the exit.<br>
           4. Avoid the Figure.</p>
        <button id="btn-start">ENTER ROOM</button>
    </div>

    <div id="death-screen">
        <h1 style="color:red">YOU DIED</h1>
        <p>The Figure heard you running.</p>
        <button onclick="location.reload()">TRY AGAIN</button>
    </div>

    <div id="win-screen">
        <h1 style="color:#00ffaa">ESCAPED!</h1>
        <p>You restored the power and unlocked the door.</p>
        <button onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <div id="jumpscare-overlay">
        <img id="scare-img" src="https://media.tenor.com/2Xy3l5sA1eAAAAAC/roblox-doors.gif" onerror="this.style.display='none'; document.getElementById('jumpscare-overlay').style.backgroundColor='red'">
    </div>

    <div id="ui">
        <div id="hud-top">
            <div class="hud-box">BREAKERS: <span id="items-count">0 / 10</span></div>
            <div class="hud-box" id="status-msg">‚ö† LOUD NOISE DETECTED ‚ö†</div>
        </div>
        <div id="center-screen">
            <div id="crosshair"></div>
            <div id="interact-text">[E] PICK UP</div>
        </div>
        <div id="controls-hint">[WASD] Move &nbsp; [C] Crouch &nbsp; [E] Interact</div>
        <div id="posture-icon">üèÉ</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. GAME VARIABLES ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let isCrouching = false;
        let isDead = false;
        let fusesFound = 0;
        
        // Physics/Movement
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const speedRun = 80.0;
        const speedCrouch = 25.0;
        
        // Entities
        const interactables = [];
        const obstacles = [];
        let figureGroup;
        let figureTarget = new THREE.Vector3();
        let figureState = 'PATROL'; // PATROL, CHASE
        let figureSpeed = 4.0;
        
        // --- 2. SETUP SCENE ---
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 0, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6; // Player height

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambient);

            // Level Generation
            createLevel();
            createFigure();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls Events
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', () => {
                if(document.pointerLockElement !== document.body && !isDead) {
                    document.body.requestPointerLock();
                }
            });
            document.addEventListener('mousemove', onMouseMove);
            
            // Resize
            window.addEventListener('resize', onWindowResize);

            // Start Button
            document.getElementById('btn-start').addEventListener('click', () => {
                document.getElementById('start-screen').style.display = 'none';
                document.body.requestPointerLock();
                startAudio();
            });
        }

        // --- 3. CUSTOM CONTROLS (Manual Implementation) ---
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        function onMouseMove(event) {
            if (document.pointerLockElement === document.body && !isDead) {
                euler.setFromQuaternion(camera.quaternion);
                euler.y -= event.movementX * 0.002;
                euler.x -= event.movementY * 0.002;
                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyC': toggleCrouch(true); break;
                case 'KeyE': interact(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyC': toggleCrouch(false); break;
            }
        }

        function toggleCrouch(down) {
            if(down) {
                isCrouching = true;
                camera.position.y = 0.8;
                document.getElementById('posture-icon').innerText = 'üßé';
            } else {
                isCrouching = false;
                camera.position.y = 1.6;
                document.getElementById('posture-icon').innerText = 'üèÉ';
            }
        }

        // --- 4. LEVEL CREATION ---
        function createLevel() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.8 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x263238 });
            const createWall = (w, h, d, x, z) => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
                mesh.position.set(x, h/2, z);
                mesh.castShadow = true; mesh.receiveShadow = true;
                scene.add(mesh);
                obstacles.push(mesh);
            };
            createWall(100, 10, 2, 0, -51);
            createWall(100, 10, 2, 0, 51);
            createWall(2, 10, 100, -51, 0);
            createWall(2, 10, 100, 51, 0);

            // Shelves (Obstacles)
            const shelfMat = new THREE.MeshStandardMaterial({ color: 0x111 });
            for (let i = 0; i < 40; i++) {
                const w = 4; const h = 6; const d = 1.5;
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                if(Math.abs(x) < 5 && Math.abs(z) < 5) continue; // Spawn safe zone

                const shelf = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), shelfMat);
                shelf.position.set(x, h/2, z);
                shelf.rotation.y = Math.random() > 0.5 ? Math.PI/2 : 0;
                shelf.castShadow = true;
                scene.add(shelf);
                obstacles.push(shelf);

                // Add random colored "books" on shelves
                const box = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1.6), new THREE.MeshStandardMaterial({color: Math.random() * 0xffffff}));
                box.position.set(x, Math.random()*5, z);
                box.rotation.y = shelf.rotation.y;
                scene.add(box);
            }

            // Lights
            for(let x=-30; x<=30; x+=30) {
                for(let z=-30; z<=30; z+=30) {
                    const pl = new THREE.PointLight(0xffaa55, 0.8, 30);
                    pl.position.set(x, 8, z);
                    pl.castShadow = true;
                    scene.add(pl);
                }
            }

            // Breakers (Collectibles)
            for(let i=0; i<10; i++) {
                const g = new THREE.Group();
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color: 0x00ffaa}));
                const l = new THREE.PointLight(0x00ffaa, 1, 5);
                g.add(m, l);
                g.position.set((Math.random()-0.5)*80, 1, (Math.random()-0.5)*80);
                g.userData = { type: 'fuse' };
                interactables.push(g);
                scene.add(g);
            }

            // Exit
            const exit = new THREE.Mesh(new THREE.BoxGeometry(4, 6, 1), new THREE.MeshStandardMaterial({color:0x555}));
            exit.position.set(0, 3, -50);
            exit.userData = { type: 'exit' };
            interactables.push(exit);
            scene.add(exit);
        }

        // --- 5. THE FIGURE ---
        function createFigure() {
            figureGroup = new THREE.Group();
            
            const mat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.2 });
            
            // Legs
            const l1 = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,1.5), mat); l1.position.set(-0.3, 0.75, 0);
            const l2 = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,1.5), mat); l2.position.set(0.3, 0.75, 0);
            
            // Torso
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.25, 1.2), mat); torso.position.set(0, 2.1, 0);
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), mat); head.position.set(0, 3.0, 0);
            // Mouth
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.4), new THREE.MeshBasicMaterial({color:0x000}));
            mouth.position.set(0, 3.0, 0.2);

            // Arms (Long)
            const a1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.8), mat); a1.position.set(-0.55, 2.2, 0.3); a1.rotation.x = -0.4;
            const a2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.8), mat); a2.position.set(0.55, 2.2, 0.3); a2.rotation.x = -0.4;

            figureGroup.add(l1,l2,torso,head,mouth,a1,a2);
            figureGroup.position.set(0, 0, 40);
            scene.add(figureGroup);
        }

        function updateFigure(dt) {
            if(isDead) return;

            const playerPos = new THREE.Vector3(camera.position.x, 0, camera.position.z);
            const figPos = figureGroup.position.clone();
            const dist = figPos.distanceTo(playerPos);
            
            // AI Logic
            const isRunning = (moveForward || moveBackward || moveLeft || moveRight) && !isCrouching;
            
            // HEARING MECHANIC
            if (isRunning && dist < 40) {
                // He hears you
                figureState = 'CHASE';
                figureTarget.copy(playerPos);
                figureSpeed = 9.0;
                document.getElementById('status-msg').style.opacity = 1;
            } else {
                document.getElementById('status-msg').style.opacity = 0;
                // If chasing but you stopped running, he goes to last spot then patrols
                if (figureState === 'CHASE' && figPos.distanceTo(figureTarget) < 2) {
                    figureState = 'PATROL';
                    figureSpeed = 3.5;
                }
            }
            
            // PATROL LOGIC
            if (figureState === 'PATROL') {
                if (figPos.distanceTo(figureTarget) < 2 || figureTarget.length() === 0) {
                    figureTarget.set(
                        (Math.random() - 0.5) * 80,
                        0,
                        (Math.random() - 0.5) * 80
                    );
                }
            }

            // Move Figure
            const dir = new THREE.Vector3().subVectors(figureTarget, figPos).normalize();
            
            // Simple obstruction avoidance
            obstacles.forEach(ob => {
                if(figPos.distanceTo(ob.position) < 4) {
                    const push = new THREE.Vector3().subVectors(figPos, ob.position).normalize();
                    dir.add(push);
                }
            });
            dir.normalize();

            // Apply movement
            figureGroup.position.addScaledVector(dir, figureSpeed * dt);
            figureGroup.lookAt(figureTarget.x, 2, figureTarget.z);
            
            // Bobbing animation
            figureGroup.position.y = Math.sin(Date.now() * 0.005) * 0.1;

            // Kill trigger
            if (dist < 1.5) {
                die();
            }
        }

        function die() {
            isDead = true;
            document.exitPointerLock();
            document.getElementById('jumpscare-overlay').style.display = 'flex';
            playSound('scream');
            setTimeout(() => {
                document.getElementById('jumpscare-overlay').style.display = 'none';
                document.getElementById('death-screen').style.display = 'flex';
            }, 1500);
        }

        // --- 6. INTERACTION & GAME LOOP ---
        function interact() {
            if(isDead) return;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true);

            if(hits.length > 0 && hits[0].distance < 4) {
                let obj = hits[0].object;
                while(obj.parent && !obj.userData.type) obj = obj.parent;

                if(obj.userData.type === 'fuse') {
                    fusesFound++;
                    playSound('collect');
                    obj.position.y = -100; // Remove
                    document.getElementById('items-count').innerText = `${fusesFound} / 10`;
                } else if(obj.userData.type === 'exit') {
                    if(fusesFound >= 10) {
                        document.exitPointerLock();
                        document.getElementById('win-screen').style.display = 'flex';
                    }
                }
            }
        }

        // Simple Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function startAudio() { if(audioCtx.state === 'suspended') audioCtx.resume(); }
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            if(type==='collect') {
                osc.type='sine'; osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime+0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime); 
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.2);
                osc.start(); osc.stop(audioCtx.currentTime+0.2);
            } else if(type==='scream') {
                osc.type='sawtooth'; osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime+1);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime); 
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+1);
                osc.start(); osc.stop(audioCtx.currentTime+1);
            }
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (!isDead && document.pointerLockElement === document.body) {
                // Movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const currentSpeed = isCrouching ? speedCrouch : speedRun;

                if (moveForward || moveBackward) velocity.z -= direction.z * currentSpeed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta;

                const moveX = -velocity.x * delta;
                const moveZ = -velocity.z * delta;

                // Move logic (Basic Camera translation)
                camera.translateX(moveX);
                camera.translateZ(moveZ);
                camera.position.y = isCrouching ? 0.8 : 1.6;

                // UI Raycast
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = raycaster.intersectObjects(interactables, true);
                const txt = document.getElementById('interact-text');
                if(hits.length > 0 && hits[0].distance < 4) {
                    txt.style.opacity = 1;
                    const type = hits[0].object.userData.type || hits[0].object.parent.userData.type;
                    if(type === 'fuse') txt.innerText = "[E] Collect Breaker";
                    if(type === 'exit') txt.innerText = fusesFound >= 10 ? "[E] ESCAPE" : "LOCKED (Need 10)";
                } else {
                    txt.style.opacity = 0;
                }
            }

            if(figureGroup) updateFigure(delta);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
